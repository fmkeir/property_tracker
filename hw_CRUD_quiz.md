# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the `Property` class?
A. In console.rb

Q2. Where are we defining the SQL that enables us to save the ruby `Property` object into the database?
A. In the model file property.rb

Q3. In `console.rb`, which lines modify the database?
A. property1.save(), property2.save(), and Property.delete_all()

Q4. Why do we not define the id of a `Property` object at the point we instantiate it (‘new it up’)?
A. The id is created by SQL when the `Property` is stored in the database (by SERIAL).

Q5. Where and how do we assign the id (that is generated by the database) to the ruby `Property` object?
A.  In CREATE TABLE we assign the datatype of id to be SERIAL PRIMARY KEY. This automatically increments the id when a new row is added. PRIMARY KEY ensures that keys cannot have identical values. It also blocks a user from reassigning an id value.
In the save method, we ask the database to return the ID when it creates the new row.
`@id = db.exec_prepared("save", values).first()["id"].to_i()`

Q6. Why do we put a guard (an `if` clause) on the `@id` attribute in the constructor?
A. Without the guard, the id would initialize to 0. We want the objects to only have an `@id` attribute if it actually relates to an id in the database.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?
A. We want instances of a class to be able to CRUD data which relates to only one row/object. Class methods should be used where we want to affect multiple rows/objects. i.e. We want to distinguish responsibility between individual instances and the owner.

Q8. What type of data structure is returned by calls to `db.exec_prepared()`? In the `save` method, how do we access the id from the returned data structure?
A. A PG result object (like an array of hashes).
`@id = db.exec_prepared("save", values).first()["id"].to_i()`
We access the first (and only) index returned to ruby, then access the "id" key which contains the id as a string.

Q9. Why do we use prepared statements when performing database operations?
A. Prepared statements simplify the syntax for inserting values into SQL commands. It also ensures that only a single SQL command is executed which protects against SQL injection attacks. It also sanitises the input and allows the user to enter non-escaped characters e.g. `'`

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the `Property` class.

Q10. What do they take in as their arguments?
A. An id (int) or an address (string).


Q11. What are their return values?
A. Either: a Property object or nil. Both methods create a new Property class from a hash in an array, if a match is found.
